# Copyright 2025 The Chromium Authors
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/config/apple/apple_sdk.gni")
import("//build/config/c++/modules.gni")
import("//build/config/clang/clang.gni")

configs_to_add = [
  "//buildtools/third_party/libc++:config",
  "//build/config/compiler:no_chromium_code",
]

configs_to_remove = [
  "//build/config/compiler:chromium_code",
  "//build/config/coverage:default_coverage",
]

if (use_clang_modules) {
  template("clang_module") {
    source_set(target_name) {
      forward_variables_from(invoker, "*", [ "modulemap" ])
      use_libcxx_modules = false
      sources = [ invoker.modulemap ]
      if (!defined(public_deps)) {
        public_deps = []
      }

      if (use_xcode_symlinks) {
        # The `copy_sysroot_modulemaps` action depends on SDK paths that differ
        # between macOS and iOS, so it must be built with the correct toolchain
        # for the target OS.
        toolchain = "//build/toolchain/mac:clang_$target_cpu"
        if (is_ios) {
          toolchain = "//build/toolchain/ios:ios_clang_$target_cpu"
        }
        public_deps += [
          "//buildtools/third_party/libc++:copy_sysroot_modulemaps($toolchain)",
        ]
      }

      # Implicit module maps won't work on apple because we're currently
      # missing some dependencies.
      if (use_autogenerated_modules) {
        # Explicitly DO NOT use public configs here. If we have two framework
        # modules foo and bar, and only foo is transitively depended on by
        # libcxx:
        # * When building the module for libcxx, we want both -fmodule-map-file
        #   for both foo and bar, to ensure that if libcxx did depend on bar, we
        #   would throw an error.
        # * We may choose not to build bar because it's so rarely used that it
        #   won't increase performance to precompile it
        # * If we provide -fmodule-map-file=bar but choose not to build bar,
        #   then any target that did depend on bar would fail to compile.
        configs += [ "//buildtools/third_party/libc++:all_modulemap_configs" ]
        if (!defined(cflags)) {
          cflags = []
        }

        # Note that this in addition to, not instead of explicit modulemaps.
        # This is simply to allow us to catch missing modules we depend on.
        cflags += [ "-fimplicit-module-maps" ]
      } else {
        if (!defined(public_configs)) {
          public_configs = []
        }

        # By always including all module maps, we can get it to error out if
        # we attempt to include something not in your dependencies.
        # Otherwise, it would silently add it to your own AST.
        public_configs += [
          "//buildtools/third_party/libc++:builtin_modulemap",
          "//buildtools/third_party/libc++:libcxx_modulemap",
          "//buildtools/third_party/libc++:sysroot_modulemaps",
        ]
      }
      configs -= configs_to_remove
      configs += configs_to_add
    }
  }

  template("builtin_module") {
    # This is a template to build modules that reside in clang builtin's module file.
    clang_module(target_name) {
      forward_variables_from(invoker, "*")
      modulemap = "${clang_base_path}/lib/clang/${clang_version}/include/module.modulemap"
      if (use_autogenerated_modules) {
        public_configs = [ "//buildtools/third_party/libc++:builtin_modulemap" ]
      }
    }
  }

  template("libcxx_module") {
    # This is a template to build modules that reside in libc++'s module file.
    clang_module(target_name) {
      forward_variables_from(invoker, "*")
      modulemap = "${root_build_dir}/gen/third_party/libc++/src/include/module.modulemap"
      deps = [
        "//buildtools/third_party/libc++:custom_headers",
        "//buildtools/third_party/libc++:libcxx_headers",
      ]
      if (use_autogenerated_modules) {
        public_configs = [ "//buildtools/third_party/libc++:libcxx_modulemap" ]
      }
    }
  }

  if (use_autogenerated_modules) {
    template("sysroot_module") {
      clang_module(target_name) {
        forward_variables_from(invoker, "*")
        modulemap = "module.modulemap"
        public_configs = [ ":sysroot_modulemap" ]
      }
    }
  } else if (is_apple) {
    template("DarwinBasic_module") {
      clang_module(target_name) {
        forward_variables_from(invoker, "*")
        modulemap = "$sdk_path/usr/include/DarwinBasic.modulemap"
      }
    }
    template("DarwinFoundation_module") {
      clang_module(target_name) {
        forward_variables_from(invoker, "*")
        modulemap = "$sdk_path/usr/include/DarwinFoundation.modulemap"
      }
    }
    template("c_standard_library_module") {
      clang_module(target_name) {
        forward_variables_from(invoker, "*")
        modulemap = "$sdk_path/usr/include/c_standard_library.modulemap"
      }
    }
  } else {
    template("sysroot_module") {
      clang_module(target_name) {
        forward_variables_from(invoker, "*")
        modulemap = sysroot_modulemap
        deps = [
          ":custom_headers",
          ":libcxx_headers",
        ]
      }
    }
  }
}

template("modulemap_config") {
  config(target_name) {
    path = rebase_path(invoker.source, root_build_dir)
    cflags_cc = [ "-fmodule-map-file=${path}" ]
  }
}

template("apple_sysroot_modulemap") {
  modulemap_config(target_name) {
    source = "${sysroot_include_dir}/${invoker.sysroot_path}"
  }
}

template("apple_sysroot_module") {
  clang_module(target_name) {
    forward_variables_from(invoker,
                           "*",
                           [
                             "modulemap",
                             "modulemap_path",
                           ])
    modulemap = "${sysroot_include_dir}/${invoker.modulemap_path}"
    public_configs = [ invoker.modulemap ]
  }
}

template("framework_modulemap") {
  modulemap_config(target_name) {
    source =
        "${frameworks_dir}/${invoker.name}.framework/Modules/module.modulemap"
  }
}

template("framework_module") {
  clang_module(target_name) {
    forward_variables_from(invoker, "*", [ "framework" ])

    # :foo_modulemap -> ${frameworks_dir}/foo.framework/Modules/module.modulemap
    modulemap = string_replace(
            string_replace(invoker.modulemap, ":", "${frameworks_dir}/"),
            "_modulemap",
            ".framework/Modules/module.modulemap")
    public_configs = [ invoker.modulemap ]

    cflags = [
      # Some frameworks don't have proper umbrellas.
      "-Wno-incomplete-umbrella",
    ]
  }
}
